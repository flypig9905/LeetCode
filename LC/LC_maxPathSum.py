'''

Created on Feb 10, 2014

@author: Songfan
'''

import sys

class TreeNode:
    def __init__(self, val = None, left = None, right = None):
        self.val = val
        self.left = left
        self.right = right
        
    def __str__(self):
        return str(self.val)
    
    
class BinaryTree:
    def __init__(self, root = None):
        self.root = root
        
    def __str__(self):
        return self._display(self.root)
    
    def _display(self, node):
        if node is None: return '*'
        return str(node.val) + '(' + self._display(node.left) + ',' + self._display(node.right) + ')'


def solution(node):
    maxS = [-sys.maxint]
    _, maxSum = dfs(node, maxS)
    return maxSum[0]
    
def dfs(node, maxS):
    if node is None: return 0, maxS
    
    # dfs
    l, maxS = dfs(node.left, maxS)
    r, maxS = dfs(node.right, maxS)
    
    # current max is generated by adding left and right (if they are positive therefore contribute to current max) to current node
    tmpS = node.val
    if l > 0: tmpS += l
    if r > 0: tmpS += r
    
    maxS[0] = max(maxS[0], tmpS)
        
    if max(l, r) > 0:
        # first return element is the current max path sum, choosing path either from left->root or right->root
        # second return element is the global max path sum
        return node.val + max(l, r), maxS
    else:
        return node.val, maxS




''' unittest '''
n1 = TreeNode(3)
n2 = TreeNode(4)
n3 = TreeNode(5)
n4 = TreeNode(3)
n5 = TreeNode(2, n1, n2)
n6 = TreeNode(2, n3, n4)
n7 = TreeNode(1, n5, n6)
print BinaryTree(n7)
print solution(n7), 'should be 14'
